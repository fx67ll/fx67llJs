## 2023年8月2日  
> 什么是js的**防抖**（`Debounce`）和**节流**（`Throttle`）？  
> 你是如何在工作中应用的？  
### 解答思路
#### 自行查询资料的结果
1. 防抖是什么？在工作中的主要应用场景？  
	- 在规定时间内多次触发函数，只执行最后一次（可以理解为LOL回城计时，打断后需要重新计时）  
	- 在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时  
	- 场景一：用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源  
	- 场景二：window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次  
2. 节流是什么？在工作中的主要应用场景？
	- 在规定时间内多次触发函数，只执行第一次  
	- 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效  
	- 场景一：鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次  
	- 场景二：在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据  
3. 防抖和节流的区别？
	- 函数防抖是某一段时间内只执行一次  
	- 而函数节流是间隔时间执行，不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数  
	- 防抖是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，都会清除当前的 timer 然后重新设置超时调用，即重新计时。这样一来，只有最后一次操作能被触发  
	- 节流是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器  
#### chatGPT的回答
1. 什么是js的防抖和节流?
```
在 JavaScript 中，防抖（debounce）和节流（throttle）是用来限制函数执行频率的两种常见技术。

防抖（debounce）是指在某个时间段内，只执行最后一次触发的函数调用。如果在这个时间段内再次触发该函数，会重新计时，直到等待时间结束才会执行函数。
这个技术通常用于处理频繁触发的事件，比如窗口大小调整、搜索框输入等。防抖可以避免函数执行过多次，减少性能负担。

节流（throttle）是指在一段时间内限制函数的执行频率，保证一定时间内只执行一次函数调用。无论触发频率多高，都会在指定时间间隔内执行一次函数。
这个技术通常用于处理连续触发的事件，比如滚动事件、鼠标移动事件等。节流可以控制函数的执行频率，
```
2. 用js写一个防抖的工具函数
```
function debounce(func, delay) {
  let timeoutId;
  
  return function() {
    const context = this;
    const args = arguments;
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(function() {
      func.apply(context, args);
    }, delay);
  };
}

这个防抖函数接受两个参数：func表示需要进行防抖的函数，delay表示延迟的时间间隔（以毫秒为单位）。函数内部使用了一个timeoutId变量来保存定时器的标识。
当调用防抖函数返回的新函数时，会清除之前的定时器，并设置一个新的定时器。只有在延迟时间内没有再次调用该新函数时，才会触发最终的函数执行。

以下是一个示例用法：

function handleScroll() {
  console.log('Scroll event debounced');
}
const debouncedScroll = debounce(handleScroll, 200);
window.addEventListener('scroll', debouncedScroll);
```
3. 用js写一个节流的工具函数
```
function throttle(func, delay) {
  let timeoutId;
  let lastExecTime = 0;

  return function(...args) {
    const currentTime = Date.now();
    const remainingTime = delay - (currentTime - lastExecTime);

    clearTimeout(timeoutId);

    if (remainingTime <= 0) {
      func.apply(this, args);
      lastExecTime = currentTime;
    } else {
      timeoutId = setTimeout(() => {
        func.apply(this, args);
        lastExecTime = Date.now();
      }, remainingTime);
    }
  };
}

这个节流函数接受两个参数：func 是要执行的函数，delay 是延迟时间（以毫秒为单位）。
它返回一个新的函数，该函数在调用时会根据指定的延迟时间来限制原始函数的执行频率。

以下是一个示例用法：
该示例中，handleScroll 函数将被限制为每 200 毫秒执行一次，即使滚动事件触发频率更高。

function handleScroll() {
  console.log('Scrolled');
}

const throttledScroll = throttle(handleScroll, 200);

window.addEventListener('scroll', throttledScroll);
```
4. 工作中哪些场景可以使用防抖函数？
```
在工作中，防抖函数可以提升性能并减少网络开销。

用户输入：当用户在表单输入框中频繁输入时，可以使用防抖函数来延迟处理用户输入，避免频繁的请求或操作，提高性能和用户体验。

搜索框：在搜索框中，当用户连续输入关键字时，可以使用防抖函数来延迟发送搜索请求，以避免请求过多。

窗口调整：当窗口大小调整时，会触发resize事件，可以使用防抖函数来限制resize事件的触发次数，避免频繁执行调整相关的代码。

按钮点击：当按钮被频繁点击时，可以使用防抖函数来限制按钮点击的触发次数，
```
5. 工作中哪些场景可以使用节流函数？
```
在工作中，节流函数可以用来控制频繁触发的事件，以减少资源消耗和提高性能。下面是一些应用节流函数的场景和步骤：

用户输入事件：当用户在文本框中输入时，触发搜索功能。使用节流函数可以限制搜索请求的频率，以避免频繁的网络请求。例如，可以设置一个定时器，在用户输入后的一小段时间内不触发搜索请求，只在定时器结束后才进行搜索。

页面滚动事件：当用户滚动页面时，触发加载更多数据的操作。使用节流函数可以限制加载操作的频率，以提高页面的响应性能。例如，可以设置一个定时器，在用户滚动过程中只触发加载操作的最后一次滚动事件。

频繁点击事件：当用户频繁点击某个按钮时，触发某个操作。使用节流函数可以限制点击操作的频率，以避免重复操作或者混乱的界面状态。例如，可以设置一个定时器，在用户点击后的一小段时间内不触发重复操作。

在实际应用中，可以使用不同编程语言或框架提供的节流函数库或实现自定义的节流函数。例如，在JavaScript中，可以使用lodash库提供的throttle函数来实现节流功能。

总结起来，通过应用节流函数，可以控制事件的触发频率，避免频繁的操作并提高系统性能。在不同的应用场景中，根据具体需求选择合适的节流函数，
```