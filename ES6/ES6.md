# ES6 学习笔记
## 第一阶段是快速过一遍简要记录下，第二阶段详细写笔记，参考资料[ES6 入门教程](https://es6.ruanyifeng.com/ "ES6 入门教程")
## 当前进度已完成至`6.数值的拓展`，下次看`7.函数的拓展`，由于函数比较繁杂放到后面看，暂时跳过看`9.数组的拓展`和`10.对象的拓展`

## ES6主体介绍
### ECMAScript和JavaScript的关系？

### ES6的简史；ES5和ES6的区别；2013年ES6草案冻结，2015年ES6正式通过
PS：ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等  
	而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准  
	本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。  

### Babel转码器；主要用于将ES6转译为ES5

### let命令；声明变量的技巧；避免变量提升；具有暂时性死区的特性；不允许重复声明

### ES6中的块级作用域与函数声明；虽然有规则但是为了老代码的兼容实际上做了一定妥协

### 立即执行函数表达式（匿名 IIFE）

### const命令；声明一个只读的常量，声明时就要赋值且之后不能再改变；const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

### ES6声明变量的六种方法

### 顶层对象属性存在的问题以及ES6解决的方式

### globalThis对象以及设计这个对象的原因；ES2020 在语言标准的层面，引入globalThis作为顶层对象

### 变量的解构赋值；ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）
+ 数组的解构赋值；模式匹配；Set结构也可以使用数组的解构赋值；只要某种数据结构具有`Iterator`接口都可以使用数组的解构赋值；解构赋值允许指定默认值
+ 对象的解构赋值；数据无序，对象必须要与属性同名；结构也可以用于嵌套结构；解构赋值允许指定默认值
+ 字符串的结构赋值，很有意思
+ 数值和布尔值的解构赋值，没看懂
+ 函数参数的解构赋值

### 变量解构赋值的用途；交换变量的值；从函数返回多个值；函数参数的定义；提取JSON值；函数参数的默认值；遍历Map结构；输入模块的指定方法
PS：这个最好每个都练习一下，在今后的生涯中对于自己代码的可读性非常有用

### 具有`Iterator`接口

## 字符串的拓展
### 字符串新增的内容，这一章内容比较冷门或者我原来掌握的太少，理解起来比较耗时间，后期注意一下
+ 字符的Unicode表示法，完全不懂......  
+ 字符串新增了`Iterator`遍历器接口  
+ 字符串允许直接输入字符，以及输入字符的转义形式，完全不懂......  
+ 改造了JSON.stringify()，根据标准JSON的数据必须是UTF-8编码，但是该方法现在可能会返回不符合UTF-8标准的字符串  
+ 模板字符串，是增强版的字符串，用反引号（`）标识  
	> 模板字符串的空格和换行，都是被保留的，如果你不想要这个换行，可以使用`.trim()`方法消除它  
	> 它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量  
	> 嵌入变量需要将变量名写在`${}`之中，如果模板字符串中的变量没有声明，将报错  
	> `${}`大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，如果大括号内部是一个字符串，将会原样输出  
	> 模板字符串之中还能调用函数`function fn() {return "Hello World"}	(反引号)foo ${fn()} bar(反引号)`  
	> 模板字符串甚至还能嵌套  
	![模板字符串甚至还能嵌套](./img/ES6嵌套字符串模板.png "模板字符串甚至还能嵌套")  
	> 如果需要引用模板字符串本身，在需要时执行，可以写成函数  
	> 模板字符串的应用实例：模板编译  
	![模板编译1](./img/模板编译1.png "模板编译1")  
	![模板编译2](./img/模板编译2.png "模板编译2")  
	![模板编译3](./img/模板编译3.png "模板编译3") 
	> 字符串模板还可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这被称为***标签模板***功能，大致明白需要详细了解......
	> ***标签模板***的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容，另一个应用，就是多语言转换（国际化处理）
	> 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能，没看懂......
	> 可以使用标签模板，在 JavaScript 语言之中嵌入其他语言（通过jsx函数，将一个 DOM 字符串转为 React 对象），牛逼，详细了解一下......
	> 但是字符串模板也是有一定的限制的，没看懂详细了解一下......

### 字符串对象新增的方法
+ `String.fromCharCode()`，用于从 Unicode 码点返回对应字符，不懂XD......
+ `String.raw()`，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法，还是不懂XD，评论区说写的有问题注意看下......
+ `String.codePointAt()`，对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，`codePointAt()`方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点
+ `String.normalize()`，许多欧洲语言有语调符号和重音符号，处理这个用的，不想了解......
+ 传统上，JavaScript 只有`indexOf()`方法，可以用来确定一个字符串是否包含在另一个字符串中，ES6 又提供了三种新方法
	> `String.includes()`，返回布尔值，表示是否找到了参数字符串  
	> `String.startsWith()`，返回布尔值，表示参数字符串是否在原字符串的头部  
	> `String.endsWith()`，返回布尔值，表示参数字符串是否在原字符串的尾部  
+ `String.repeat()`，返回一个新字符串，表示将原字符串重复n次
+ ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全
	> `String.padStart()`，用于头部补全  
	> `String.padEnd()`，用于尾部补全  
+ ES2019 对字符串实例新增了`trimStart()`和`trimEnd()`这两个方法，它们的行为与`trim()`一致
	> `String.trimStart()`，用于消除字符串头部的空格  
	> `String.trimEnd()`，用于消除字符串尾部的空格  
+ `String.matchAll()`，用于返回一个正则表达式在当前字符串的所有匹配，正则的拓展对此会有详细讲解注意下......
+ `String.replaceAll()`，历史上，字符串的实例方法replace()只能替换第一个匹配，ES2021 引入了replaceAll()方法，可以一次性替换所有匹配
	> `String.prototype.replaceAll(searchValue, replacement)`  
	> searchValue是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有g修饰符）  
	> 如果searchValue是一个不带有g修饰符的正则表达式，replaceAll()会报错，这一点跟replace()不同  
	> replaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串  
	![replaceAll第二个参数可以使用一些特殊字符串](./img/replaceAll第二个参数可以使用一些特殊字符串.png "replaceAll第二个参数可以使用一些特殊字符串")

## 正则的拓展
### 正则新增的内容，我想直接忽略，因为正则我完全一窍不通，后期抽空专题学习研究下

## 数值对象的拓展
### 数值对象新增的内容
+ 提供了二进制和八进制数值的新的写法
	> 前缀`0b`（或`0B`）表示二进制  
	> 前缀`0o`（或`0O`）表示八进制  
+ `Number.isFinite()`，用来检查一个数值是否为有限的，注意，如果参数类型不是数值，`isFinite()`一律返回false
+ `Number.isNaN()`，用来检查一个值是否为NaN，注意，如果参数类型不是NaN，`isNaN()`一律返回false
+ ES6 将全局方法`parseInt()`和`parseFloat()`，移植到Number对象上面，行为完全保持不变，这样做的目的，是逐步减少全局性方法，使得语言逐步模块化
```
	// ES5的写法
	parseInt('12.34') // 12
	parseFloat('123.45#') // 123.45

	// ES6的写法
	Number.parseInt('12.34') // 12
	Number.parseFloat('123.45#') // 123.45
```
+ `Number.isInteger()`，用来判断一个数值是否为整数，如果参数不是数值，`isInteger()`返回false
	> JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值  
	> 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）  
	> 如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，`isInteger()`可能会误判  
	> 下方代码示例第1行中，`isInteger()`的参数明明不是整数，但是会返回true,原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了 
	> 类似的情况还有，下方代码示例23行中，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0，这时，`isInteger()`也会误判  
	> 总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数  
```
	Number.isInteger(3.0000000000000002) // true

	Number.isInteger(5E-324) // false  
	Number.isInteger(5E-325) // true
```
+ `Number.EPSILON`，在Number对象上面，新增一个极小的常量Number.EPSILON，根据规格，它表示 1 与大于 1 的最小浮点数之间的差  
	> 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001(小数点后面有连续 51 个零)，这个值减去 1 之后，就等于 2 的 -52 次方  
	> `Number.EPSILON`实际上是 JavaScript 能够表示的最小精度，误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了  
	> `Number.EPSILON`可以用来设置***能够接受的误差范围***  
	> 比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等  
	
+ `Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`，这两个常量，JavaScript 能够准确表示的整数范围的上下限
	> JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值  
	> 下方代码示例中，超出 2 的 53 次方之后，一个数就不精确了  
```
	Math.pow(2, 53) // 9007199254740992

	9007199254740992  // 9007199254740992
	9007199254740993  // 9007199254740992

	Math.pow(2, 53) === Math.pow(2, 53) + 1
	// true

	Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
	// true
	Number.MAX_SAFE_INTEGER === 9007199254740991
	// true

	Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
	// true
	Number.MIN_SAFE_INTEGER === -9007199254740991
	// true
```
+ `Number.isSafeInteger()`，用来判断一个整数是否落在 JavaScript 能够准确表示的整数范围之内
	> 实际使用这个函数时，需要注意，验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值  

### Math对象新增的方法，仅做了解，对于我目前的工作来说很少会涉及到复杂数学计算
+ ES6 在 Math 对象上新增了 17 个与数学相关的方法，所有这些方法都是静态方法，只能在 Math 对象上调用
+ `Math.trunc()`，用于去除一个数的小数部分，返回整数部分
+ `Math.sign()`，用来判断一个数到底是正数、负数、还是零，对于非数值，会先将其转换为数值，它会返回五种值
	> 参数为正数，返回 +1  
	> 参数为负数，返回 -1  
	> 参数为 0，返回 0  
	> 参数为 -0，返回 -0  
	> 其他值，返回NaN  
+ `Math.cbrt()`，用于计算一个数的立方根
+ `Math.clz32()`，将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0，不懂，后期详细了解下......
	> clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写  
+ `Math.imul()`，返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数，不懂，后期详细了解下......
+ `Math.fround`，返回一个数的32位单精度浮点数形式，不懂，后期详细了解下......
+ `Math.hypot()`，返回所有参数的平方和的平方根
+ `Math.expm1(x)`，对数相关方法，后期详细了解下可以用于中学数学......
+ `Math.log1p(x)`，对数相关方法，后期详细了解下可以用于中学数学......
+ `Math.log10(x)`，对数相关方法，后期详细了解下可以用于中学数学......
+ `Math.log2(x)`，对数相关方法，后期详细了解下可以用于中学数学......
+ `Math.inh(x)`，双曲线函数相关方法，后期详细了解下可以用于中学数学......
+ `Math.cosh(x)`，双曲线函数相关方法，后期详细了解下可以用于中学数学......
+ `Math.tanh(x)`，双曲线函数相关方法，后期详细了解下可以用于中学数学......
+ `Math.asinh(x)`，双曲线函数相关方法，后期详细了解下可以用于中学数学......
+ `Math.acosh(x)`，双曲线函数相关方法，后期详细了解下可以用于中学数学......
+ `Math.atanh(x)`，双曲线函数相关方法，后期详细了解下可以用于中学数学......

### 指数运算符
+ ES2016 新增了一个指数运算符（**）
+ 这个运算符的一个特点是右结合，而不是常见的左结合，多个指数运算符连用时，是从最右边开始计算的
+ 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）
```
	2 ** 2 // 4
	2 ** 3 // 8

	// 相当于 2 ** (3 ** 2)
	2 ** 3 ** 2
	// 512

	let a = 1.5;
	a **= 2;
	// 等同于 a = a * a;

	let b = 4;
	b **= 3;
	// 等同于 b = b * b * b;
```

### BigInt，***看函数前先把这个收尾！！！！！！***

## 函数的拓展
### 函数新增的内容，抽空集中时间看

## 数组的拓展
### 数组新增的内容
+ 拓展运算符